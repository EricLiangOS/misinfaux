{"ast":null,"code":"import React,{useState,useEffect}from'react';import{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";const TextDisplay=_ref=>{let{text,problematicElements}=_ref;const[highlightedText,setHighlightedText]=useState('');const[annotations,setAnnotations]=useState([]);useEffect(()=>{if(!text||!problematicElements)return;const allProblematicWords=[...problematicElements.overusedWords,...problematicElements.suspiciousWords];// Create a map of problematic words to annotations\nconst wordAnnotations={};problematicElements.overusedWords.forEach(word=>{wordAnnotations[word]=`\"${word}\" is repeated excessively, which is a common tactic in misleading content.`;});problematicElements.suspiciousWords.forEach(word=>{wordAnnotations[word]=`\"${word}\" is a loaded term often used in misleading articles to evoke emotional responses.`;});// Process text to add highlight spans\nlet processedText=text;let currentAnnotations=[];let annotationId=0;// Track which words have already been highlighted\nconst highlightedWords=new Set();allProblematicWords.forEach(word=>{// Skip if we've already highlighted this word\nif(highlightedWords.has(word.toLowerCase()))return;const regex=new RegExp(`\\\\b${word}\\\\b`,'i');// Only find the first match with non-global regex\nconst match=regex.exec(text);if(match){const id=`annotation-${annotationId++}`;const start=match.index;const end=start+word.length;currentAnnotations.push({id,word,position:start,text:wordAnnotations[word.toLowerCase()]});// Add to the set of highlighted words\nhighlightedWords.add(word.toLowerCase());}});// Sort annotations by position\ncurrentAnnotations.sort((a,b)=>a.position-b.position);// Create HTML with highlighted spans\nlet currentPosition=0;let result='';currentAnnotations.forEach(annotation=>{const{id,word,position}=annotation;// Add text before the current word\nif(position>currentPosition){result+=text.substring(currentPosition,position);}// Add the highlighted word\nresult+=`<span class=\"highlighted-text\" id=\"${id}\">${text.substring(position,position+word.length)}</span>`;// Update current position\ncurrentPosition=position+word.length;});// Add any remaining text\nif(currentPosition<text.length){result+=text.substring(currentPosition);}setHighlightedText(result);setAnnotations(currentAnnotations);},[text,problematicElements]);return/*#__PURE__*/_jsxs(\"div\",{className:\"text-analysis-container\",children:[/*#__PURE__*/_jsxs(\"div\",{className:\"original-text\",children:[/*#__PURE__*/_jsx(\"h3\",{children:\"Article Content\"}),/*#__PURE__*/_jsx(\"div\",{className:\"text-content\",dangerouslySetInnerHTML:{__html:highlightedText}})]}),/*#__PURE__*/_jsxs(\"div\",{className:\"annotations-panel\",children:[/*#__PURE__*/_jsx(\"h3\",{children:\"Content Analysis\"}),annotations.length>0?/*#__PURE__*/_jsx(\"ul\",{className:\"annotations-list\",children:annotations.map(annotation=>/*#__PURE__*/_jsxs(\"li\",{className:\"annotation-item\",children:[/*#__PURE__*/_jsxs(\"span\",{className:\"annotation-word\",children:[\"\\\"\",annotation.word,\"\\\"\"]}),/*#__PURE__*/_jsx(\"p\",{className:\"annotation-text\",children:annotation.text})]},annotation.id))}):/*#__PURE__*/_jsx(\"p\",{children:\"No problematic elements detected in the text.\"})]})]});};export default TextDisplay;","map":{"version":3,"names":["React","useState","useEffect","jsx","_jsx","jsxs","_jsxs","TextDisplay","_ref","text","problematicElements","highlightedText","setHighlightedText","annotations","setAnnotations","allProblematicWords","overusedWords","suspiciousWords","wordAnnotations","forEach","word","processedText","currentAnnotations","annotationId","highlightedWords","Set","has","toLowerCase","regex","RegExp","match","exec","id","start","index","end","length","push","position","add","sort","a","b","currentPosition","result","annotation","substring","className","children","dangerouslySetInnerHTML","__html","map"],"sources":["/Users/ehliang/Desktop/Projects/misinfaux/misinfaux/frontend/src/components/TextDisplay.js"],"sourcesContent":["import React, { useState, useEffect } from 'react';\n\nconst TextDisplay = ({ text, problematicElements }) => {\n    const [highlightedText, setHighlightedText] = useState('');\n    const [annotations, setAnnotations] = useState([]);\n    \n    useEffect(() => {\n        if (!text || !problematicElements) return;\n        \n        const allProblematicWords = [\n            ...problematicElements.overusedWords,\n            ...problematicElements.suspiciousWords\n        ];\n        \n        // Create a map of problematic words to annotations\n        const wordAnnotations = {};\n        problematicElements.overusedWords.forEach(word => {\n            wordAnnotations[word] = `\"${word}\" is repeated excessively, which is a common tactic in misleading content.`;\n        });\n        \n        problematicElements.suspiciousWords.forEach(word => {\n            wordAnnotations[word] = `\"${word}\" is a loaded term often used in misleading articles to evoke emotional responses.`;\n        });\n        \n        // Process text to add highlight spans\n        let processedText = text;\n        let currentAnnotations = [];\n        let annotationId = 0;\n        \n        // Track which words have already been highlighted\n        const highlightedWords = new Set();\n        \n        allProblematicWords.forEach(word => {\n            // Skip if we've already highlighted this word\n            if (highlightedWords.has(word.toLowerCase())) return;\n            \n            const regex = new RegExp(`\\\\b${word}\\\\b`, 'i'); // Only find the first match with non-global regex\n            const match = regex.exec(text);\n            \n            if (match) {\n                const id = `annotation-${annotationId++}`;\n                const start = match.index;\n                const end = start + word.length;\n                \n                currentAnnotations.push({\n                    id,\n                    word,\n                    position: start,\n                    text: wordAnnotations[word.toLowerCase()]\n                });\n                \n                // Add to the set of highlighted words\n                highlightedWords.add(word.toLowerCase());\n            }\n        });\n        \n        // Sort annotations by position\n        currentAnnotations.sort((a, b) => a.position - b.position);\n        \n        // Create HTML with highlighted spans\n        let currentPosition = 0;\n        let result = '';\n        \n        currentAnnotations.forEach(annotation => {\n            const { id, word, position } = annotation;\n            \n            // Add text before the current word\n            if (position > currentPosition) {\n                result += text.substring(currentPosition, position);\n            }\n            \n            // Add the highlighted word\n            result += `<span class=\"highlighted-text\" id=\"${id}\">${text.substring(position, position + word.length)}</span>`;\n            \n            // Update current position\n            currentPosition = position + word.length;\n        });\n        \n        // Add any remaining text\n        if (currentPosition < text.length) {\n            result += text.substring(currentPosition);\n        }\n        \n        setHighlightedText(result);\n        setAnnotations(currentAnnotations);\n        \n    }, [text, problematicElements]);\n    \n    return (\n        <div className=\"text-analysis-container\">\n            <div className=\"original-text\">\n                <h3>Article Content</h3>\n                <div \n                    className=\"text-content\" \n                    dangerouslySetInnerHTML={{ __html: highlightedText }}\n                />\n            </div>\n            \n            <div className=\"annotations-panel\">\n                <h3>Content Analysis</h3>\n                {annotations.length > 0 ? (\n                    <ul className=\"annotations-list\">\n                        {annotations.map(annotation => (\n                            <li key={annotation.id} className=\"annotation-item\">\n                                <span className=\"annotation-word\">\"{annotation.word}\"</span>\n                                <p className=\"annotation-text\">{annotation.text}</p>\n                            </li>\n                        ))}\n                    </ul>\n                ) : (\n                    <p>No problematic elements detected in the text.</p>\n                )}\n            </div>\n        </div>\n    );\n};\n\nexport default TextDisplay;"],"mappings":"AAAA,MAAO,CAAAA,KAAK,EAAIC,QAAQ,CAAEC,SAAS,KAAQ,OAAO,CAAC,OAAAC,GAAA,IAAAC,IAAA,CAAAC,IAAA,IAAAC,KAAA,yBAEnD,KAAM,CAAAC,WAAW,CAAGC,IAAA,EAAmC,IAAlC,CAAEC,IAAI,CAAEC,mBAAoB,CAAC,CAAAF,IAAA,CAC9C,KAAM,CAACG,eAAe,CAAEC,kBAAkB,CAAC,CAAGX,QAAQ,CAAC,EAAE,CAAC,CAC1D,KAAM,CAACY,WAAW,CAAEC,cAAc,CAAC,CAAGb,QAAQ,CAAC,EAAE,CAAC,CAElDC,SAAS,CAAC,IAAM,CACZ,GAAI,CAACO,IAAI,EAAI,CAACC,mBAAmB,CAAE,OAEnC,KAAM,CAAAK,mBAAmB,CAAG,CACxB,GAAGL,mBAAmB,CAACM,aAAa,CACpC,GAAGN,mBAAmB,CAACO,eAAe,CACzC,CAED;AACA,KAAM,CAAAC,eAAe,CAAG,CAAC,CAAC,CAC1BR,mBAAmB,CAACM,aAAa,CAACG,OAAO,CAACC,IAAI,EAAI,CAC9CF,eAAe,CAACE,IAAI,CAAC,CAAG,IAAIA,IAAI,4EAA4E,CAChH,CAAC,CAAC,CAEFV,mBAAmB,CAACO,eAAe,CAACE,OAAO,CAACC,IAAI,EAAI,CAChDF,eAAe,CAACE,IAAI,CAAC,CAAG,IAAIA,IAAI,oFAAoF,CACxH,CAAC,CAAC,CAEF;AACA,GAAI,CAAAC,aAAa,CAAGZ,IAAI,CACxB,GAAI,CAAAa,kBAAkB,CAAG,EAAE,CAC3B,GAAI,CAAAC,YAAY,CAAG,CAAC,CAEpB;AACA,KAAM,CAAAC,gBAAgB,CAAG,GAAI,CAAAC,GAAG,CAAC,CAAC,CAElCV,mBAAmB,CAACI,OAAO,CAACC,IAAI,EAAI,CAChC;AACA,GAAII,gBAAgB,CAACE,GAAG,CAACN,IAAI,CAACO,WAAW,CAAC,CAAC,CAAC,CAAE,OAE9C,KAAM,CAAAC,KAAK,CAAG,GAAI,CAAAC,MAAM,CAAC,MAAMT,IAAI,KAAK,CAAE,GAAG,CAAC,CAAE;AAChD,KAAM,CAAAU,KAAK,CAAGF,KAAK,CAACG,IAAI,CAACtB,IAAI,CAAC,CAE9B,GAAIqB,KAAK,CAAE,CACP,KAAM,CAAAE,EAAE,CAAG,cAAcT,YAAY,EAAE,EAAE,CACzC,KAAM,CAAAU,KAAK,CAAGH,KAAK,CAACI,KAAK,CACzB,KAAM,CAAAC,GAAG,CAAGF,KAAK,CAAGb,IAAI,CAACgB,MAAM,CAE/Bd,kBAAkB,CAACe,IAAI,CAAC,CACpBL,EAAE,CACFZ,IAAI,CACJkB,QAAQ,CAAEL,KAAK,CACfxB,IAAI,CAAES,eAAe,CAACE,IAAI,CAACO,WAAW,CAAC,CAAC,CAC5C,CAAC,CAAC,CAEF;AACAH,gBAAgB,CAACe,GAAG,CAACnB,IAAI,CAACO,WAAW,CAAC,CAAC,CAAC,CAC5C,CACJ,CAAC,CAAC,CAEF;AACAL,kBAAkB,CAACkB,IAAI,CAAC,CAACC,CAAC,CAAEC,CAAC,GAAKD,CAAC,CAACH,QAAQ,CAAGI,CAAC,CAACJ,QAAQ,CAAC,CAE1D;AACA,GAAI,CAAAK,eAAe,CAAG,CAAC,CACvB,GAAI,CAAAC,MAAM,CAAG,EAAE,CAEftB,kBAAkB,CAACH,OAAO,CAAC0B,UAAU,EAAI,CACrC,KAAM,CAAEb,EAAE,CAAEZ,IAAI,CAAEkB,QAAS,CAAC,CAAGO,UAAU,CAEzC;AACA,GAAIP,QAAQ,CAAGK,eAAe,CAAE,CAC5BC,MAAM,EAAInC,IAAI,CAACqC,SAAS,CAACH,eAAe,CAAEL,QAAQ,CAAC,CACvD,CAEA;AACAM,MAAM,EAAI,sCAAsCZ,EAAE,KAAKvB,IAAI,CAACqC,SAAS,CAACR,QAAQ,CAAEA,QAAQ,CAAGlB,IAAI,CAACgB,MAAM,CAAC,SAAS,CAEhH;AACAO,eAAe,CAAGL,QAAQ,CAAGlB,IAAI,CAACgB,MAAM,CAC5C,CAAC,CAAC,CAEF;AACA,GAAIO,eAAe,CAAGlC,IAAI,CAAC2B,MAAM,CAAE,CAC/BQ,MAAM,EAAInC,IAAI,CAACqC,SAAS,CAACH,eAAe,CAAC,CAC7C,CAEA/B,kBAAkB,CAACgC,MAAM,CAAC,CAC1B9B,cAAc,CAACQ,kBAAkB,CAAC,CAEtC,CAAC,CAAE,CAACb,IAAI,CAAEC,mBAAmB,CAAC,CAAC,CAE/B,mBACIJ,KAAA,QAAKyC,SAAS,CAAC,yBAAyB,CAAAC,QAAA,eACpC1C,KAAA,QAAKyC,SAAS,CAAC,eAAe,CAAAC,QAAA,eAC1B5C,IAAA,OAAA4C,QAAA,CAAI,iBAAe,CAAI,CAAC,cACxB5C,IAAA,QACI2C,SAAS,CAAC,cAAc,CACxBE,uBAAuB,CAAE,CAAEC,MAAM,CAAEvC,eAAgB,CAAE,CACxD,CAAC,EACD,CAAC,cAENL,KAAA,QAAKyC,SAAS,CAAC,mBAAmB,CAAAC,QAAA,eAC9B5C,IAAA,OAAA4C,QAAA,CAAI,kBAAgB,CAAI,CAAC,CACxBnC,WAAW,CAACuB,MAAM,CAAG,CAAC,cACnBhC,IAAA,OAAI2C,SAAS,CAAC,kBAAkB,CAAAC,QAAA,CAC3BnC,WAAW,CAACsC,GAAG,CAACN,UAAU,eACvBvC,KAAA,OAAwByC,SAAS,CAAC,iBAAiB,CAAAC,QAAA,eAC/C1C,KAAA,SAAMyC,SAAS,CAAC,iBAAiB,CAAAC,QAAA,EAAC,IAAC,CAACH,UAAU,CAACzB,IAAI,CAAC,IAAC,EAAM,CAAC,cAC5DhB,IAAA,MAAG2C,SAAS,CAAC,iBAAiB,CAAAC,QAAA,CAAEH,UAAU,CAACpC,IAAI,CAAI,CAAC,GAF/CoC,UAAU,CAACb,EAGhB,CACP,CAAC,CACF,CAAC,cAEL5B,IAAA,MAAA4C,QAAA,CAAG,+CAA6C,CAAG,CACtD,EACA,CAAC,EACL,CAAC,CAEd,CAAC,CAED,cAAe,CAAAzC,WAAW","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}